{
  "version": 3,
  "sources": ["../../assets/js/phoenix/utils.ts", "../../assets/js/phoenix/constants.ts", "../../assets/js/phoenix/push.ts", "../../assets/js/phoenix/timer.ts", "../../assets/js/phoenix/channel.ts", "../../assets/js/phoenix/ajax.ts", "../../assets/js/phoenix/longpoll.ts", "../../assets/js/phoenix/presence.ts", "../../assets/js/phoenix/serializer.ts", "../../assets/js/phoenix/socket.ts"],
  "sourcesContent": ["// wraps value in closure or returns closure\nexport function closure<T>(value: T | (() => T)): () => T {\n  if (typeof value === \"function\") {\n    return value as () => T;\n  } else {\n    return () => value;\n  }\n}\n", "export const globalSelf = typeof self !== \"undefined\" ? self : null;\nexport const phxWindow = typeof window !== \"undefined\" ? window : null;\nexport const global = globalSelf || phxWindow || globalThis;\nexport const DEFAULT_VSN = \"2.0.0\";\n\nexport const SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3,\n} as const;\n\nexport type SocketState = (typeof SOCKET_STATES)[keyof typeof SOCKET_STATES];\n\nexport const DEFAULT_TIMEOUT = 10000;\nexport const WS_CLOSE_NORMAL = 1000;\n\nexport const CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\",\n} as const;\n\nexport type ChannelState = (typeof CHANNEL_STATES)[keyof typeof CHANNEL_STATES];\n\nexport const CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\",\n} as const;\n\nexport type ChannelEvent = (typeof CHANNEL_EVENTS)[keyof typeof CHANNEL_EVENTS];\n\nexport const TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\",\n} as const;\n\nexport type Transport = (typeof TRANSPORTS)[keyof typeof TRANSPORTS];\n\nexport const XHR_STATES = {\n  complete: 4,\n} as const;\n\nexport const AUTH_TOKEN_PREFIX = \"base64url.bearer.phx.\";\n", "import type Channel from \"./channel\";\n\nexport interface PushResponse {\n  status: string;\n  response: any;\n  _ref?: string;\n}\n\nexport interface ReceiveHook {\n  status: string;\n  callback: (response: any) => void;\n}\n\n/**\n * Initializes the Push\n * @param channel - The Channel\n * @param event - The event, for example `\"phx_join\"`\n * @param payload - The payload, for example `{user_id: 123}`\n * @param timeout - The push timeout in milliseconds\n * @internal\n */\nexport default class Push {\n  public channel: Channel;\n  public event: string;\n  public payload: () => any;\n  public receivedResp: PushResponse | null;\n  public timeout: number;\n  public timeoutTimer: number | null;\n  public recHooks: ReceiveHook[];\n  public sent: boolean;\n  public ref: string | null;\n  public refEvent: string | null;\n\n  constructor(\n    channel: Channel,\n    event: string,\n    payload: any | (() => any),\n    timeout: number,\n  ) {\n    this.channel = channel;\n    this.event = event;\n    this.payload =\n      typeof payload === \"function\" ? payload : () => payload || {};\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n    this.ref = null;\n    this.refEvent = null;\n  }\n\n  /**\n   * Resend the push with a new timeout\n   */\n  resend(timeout: number): void {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n\n  /**\n   * Send the push\n   */\n  send(): void {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef(),\n    });\n  }\n\n  /**\n   * Register a callback for a specific response status\n   */\n  receive(status: string, callback: (response: any) => void): Push {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp!.response);\n    }\n\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  reset(): void {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n\n  /**\n   * @private\n   */\n  matchReceive({ status, response, _ref }: PushResponse): void {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response));\n  }\n\n  /**\n   * @private\n   */\n  cancelRefEvent(): void {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel.off(this.refEvent);\n  }\n\n  /**\n   * @private\n   */\n  cancelTimeout(): void {\n    if (this.timeoutTimer !== null) {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n  }\n\n  /**\n   * @private\n   */\n  startTimeout(): void {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n\n    this.channel.on(this.refEvent, (payload: PushResponse) => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout) as any;\n  }\n\n  /**\n   * @private\n   */\n  hasReceived(status: string): boolean {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n\n  /**\n   * @private\n   */\n  trigger(status: string, response: any): void {\n    this.channel.trigger(this.refEvent!, { status, response });\n  }\n}\n", "/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n  private callback: () => void;\n  private timerCalc: (tries: number) => number;\n  private timer: number | null;\n  private tries: number;\n\n  constructor(callback: () => void, timerCalc: (tries: number) => number) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  reset(): void {\n    this.tries = 0;\n    if (this.timer !== null) {\n      clearTimeout(this.timer);\n    }\n  }\n\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout(): void {\n    if (this.timer !== null) {\n      clearTimeout(this.timer);\n    }\n\n    this.timer = setTimeout(\n      () => {\n        this.tries = this.tries + 1;\n        this.callback();\n      },\n      this.timerCalc(this.tries + 1),\n    ) as any;\n  }\n}\n", "import { closure } from \"./utils\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES, type ChannelState } from \"./constants\";\n\nimport Push from \"./push\";\nimport Timer from \"./timer\";\nimport type Socket from \"./socket\";\n\nexport interface ChannelBinding {\n  event: string;\n  ref: number;\n  callback: (payload: any, ref?: string, joinRef?: string) => void;\n}\n\n/**\n * Channel class for Phoenix WebSocket communication\n */\nexport default class Channel {\n  public state: ChannelState;\n  public topic: string;\n  public params: () => any;\n  public socket: Socket;\n  public bindings: ChannelBinding[];\n  public bindingRef: number;\n  public timeout: number;\n  public joinedOnce: boolean;\n  public joinPush: Push;\n  public pushBuffer: Push[];\n  public stateChangeRefs: string[];\n  public rejoinTimer: Timer;\n\n  constructor(topic: string, params: any | (() => any), socket: Socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout,\n    );\n    this.pushBuffer = [];\n    this.stateChangeRefs = [];\n\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.stateChangeRefs.push(\n      this.socket.onError(() => this.rejoinTimer.reset()),\n    );\n    this.stateChangeRefs.push(\n      this.socket.onOpen(() => {\n        this.rejoinTimer.reset();\n        if (this.isErrored()) {\n          this.rejoin();\n        }\n      }),\n    );\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError((reason: any) => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n      this.state = CHANNEL_STATES.errored;\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\n          \"channel\",\n          `timeout ${this.topic} (${this.joinRef()})`,\n          this.joinPush.timeout,\n        );\n      const leavePush = new Push(\n        this,\n        CHANNEL_EVENTS.leave,\n        closure({}),\n        this.timeout,\n      );\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload: any, ref?: string) => {\n      this.trigger(this.replyEventName(ref!), payload);\n    });\n  }\n\n  /**\n   * Join the channel\n   */\n  join(timeout: number = this.timeout): Push {\n    if (this.joinedOnce) {\n      throw new Error(\n        \"tried to join multiple times. 'join' can only be called a single time per channel instance\",\n      );\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n\n  /**\n   * Hook into channel close\n   */\n  onClose(\n    callback: (payload?: any, ref?: string, joinRef?: string) => void,\n  ): number {\n    return this.on(CHANNEL_EVENTS.close, callback);\n  }\n\n  /**\n   * Hook into channel errors\n   */\n  onError(\n    callback: (reason: any, ref?: string, joinRef?: string) => void,\n  ): number {\n    return this.on(CHANNEL_EVENTS.error, (reason: any) => callback(reason));\n  }\n\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   */\n  on(\n    event: string,\n    callback: (payload: any, ref?: string, joinRef?: string) => void,\n  ): number {\n    const ref = this.bindingRef++;\n    this.bindings.push({ event, ref, callback });\n    return ref;\n  }\n\n  /**\n   * Unsubscribes off of channel events\n   *\n   * Use the ref returned from a channel.on() to unsubscribe one\n   * handler, or pass nothing for the ref to unsubscribe all\n   * handlers for the given event.\n   *\n   * @example\n   * // Unsubscribe the do_stuff handler\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * channel.off(\"event\", ref1)\n   *\n   * // Unsubscribe all handlers from event\n   * channel.off(\"event\")\n   */\n  off(event: string, ref?: number): void {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(\n        bind.event === event &&\n        (typeof ref === \"undefined\" || ref === bind.ref)\n      );\n    });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  canPush(): boolean {\n    return this.socket.isConnected() && this.isJoined();\n  }\n\n  /**\n   * Sends a message `event` to phoenix with the payload `payload`.\n   * Phoenix receives this in the `handle_in(event, payload, socket)`\n   * function. if phoenix replies or it times out (default 10000ms),\n   * then optionally the reply can be received.\n   *\n   * @example\n   * channel.push(\"event\")\n   *   .receive(\"ok\", payload => console.log(\"phoenix replied:\", payload))\n   *   .receive(\"error\", err => console.log(\"phoenix errored\", err))\n   *   .receive(\"timeout\", () => console.log(\"timed out pushing\"))\n   */\n  push(event: string, payload: any = {}, timeout: number = this.timeout): Push {\n    if (!this.joinedOnce) {\n      throw new Error(\n        `tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`,\n      );\n    }\n    const pushEvent = new Push(this, event, () => payload, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   */\n  leave(timeout: number = this.timeout): Push {\n    this.rejoinTimer.reset();\n    this.joinPush.cancelTimeout();\n\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n    const leavePush = new Push(\n      this,\n      CHANNEL_EVENTS.leave,\n      closure({}),\n      timeout,\n    );\n    leavePush\n      .receive(\"ok\", () => onClose())\n      .receive(\"timeout\", () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n\n    return leavePush;\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   */\n  onMessage(\n    _event: string,\n    payload: any,\n    _ref?: string,\n    _joinRef?: string,\n  ): any {\n    return payload;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  isMember(\n    topic: string,\n    event: string,\n    payload: any,\n    joinRef?: string,\n  ): boolean {\n    if (this.topic !== topic) {\n      return false;\n    }\n\n    if (joinRef && joinRef !== this.joinRef()) {\n      if (this.socket.hasLogger())\n        this.socket.log(\"channel\", \"dropping outdated message\", {\n          topic,\n          event,\n          payload,\n          joinRef,\n        });\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  joinRef(): string | null {\n    return this.joinPush.ref;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  rejoin(timeout: number = this.timeout): void {\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  trigger(event: string, payload: any, ref?: string, joinRef?: string): void {\n    const handledPayload = this.onMessage(event, payload, ref, joinRef);\n    if (payload && !handledPayload) {\n      throw new Error(\n        \"channel onMessage callbacks must return the payload, modified or unmodified\",\n      );\n    }\n\n    const eventBindings = this.bindings.filter((bind) => bind.event === event);\n\n    for (let i = 0; i < eventBindings.length; i++) {\n      const bind = eventBindings[i]!;\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  replyEventName(ref: string): string {\n    return `chan_reply_${ref}`;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  isErrored(): boolean {\n    return this.state === CHANNEL_STATES.errored;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n}\n", "import { global, XHR_STATES } from \"./constants\";\n\ntype HttpMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\ntype Headers = Record<string, string>;\ntype RequestBody = string | null;\ntype AjaxCallback = (response: any) => void;\ntype TimeoutCallback = () => void;\n\ninterface XDomainRequest {\n  timeout: number;\n  open(method: string, url: string): void;\n  send(body?: string | null): void;\n  onload: (() => void) | null;\n  ontimeout: (() => void) | null;\n  onprogress: (() => void) | null;\n  responseText: string;\n}\n\ninterface XMLHttpRequestLike {\n  open(method: string, url: string, async?: boolean): void;\n  send(body?: string | null): void;\n  setRequestHeader(name: string, value: string): void;\n  timeout: number;\n  readyState: number;\n  responseText: string;\n  onreadystatechange: ((ev?: any) => any) | null;\n  onerror: (() => void) | null;\n  ontimeout: (() => void) | null;\n}\n\nexport default class Ajax {\n  static request(\n    method: HttpMethod,\n    endPoint: string,\n    headers: Headers,\n    body: RequestBody,\n    timeout: number,\n    ontimeout: TimeoutCallback | null,\n    callback: AjaxCallback | null,\n  ): XMLHttpRequestLike | XDomainRequest | AbortController {\n    if ((global as any).XDomainRequest) {\n      const req = new (global as any).XDomainRequest(); // IE8, IE9\n      return this.xdomainRequest(\n        req,\n        method,\n        endPoint,\n        body,\n        timeout,\n        ontimeout,\n        callback,\n      );\n    } else if ((global as any).XMLHttpRequest) {\n      const req = new (global as any).XMLHttpRequest(); // IE7+, Firefox, Chrome, Opera, Safari\n      return this.xhrRequest(\n        req,\n        method,\n        endPoint,\n        headers,\n        body,\n        timeout,\n        ontimeout,\n        callback,\n      );\n    } else if (\n      typeof global.fetch === \"function\" &&\n      typeof global.AbortController === \"function\"\n    ) {\n      // Fetch with AbortController for modern browsers\n      return this.fetchRequest(\n        method,\n        endPoint,\n        headers,\n        body,\n        timeout,\n        ontimeout,\n        callback,\n      );\n    } else {\n      throw new Error(\"No suitable XMLHttpRequest implementation found\");\n    }\n  }\n\n  static fetchRequest(\n    method: HttpMethod,\n    endPoint: string,\n    headers: Headers,\n    body: RequestBody,\n    timeout: number,\n    ontimeout: TimeoutCallback | null,\n    callback: AjaxCallback | null,\n  ): AbortController {\n    const options: RequestInit = {\n      method,\n      headers,\n      body,\n    };\n    const controller = new AbortController();\n    if (timeout) {\n      setTimeout(() => controller.abort(), timeout);\n      options.signal = controller.signal;\n    }\n    global\n      .fetch(endPoint, options)\n      .then((response) => response.text())\n      .then((data) => this.parseJSON(data))\n      .then((data) => callback && callback(data))\n      .catch((err) => {\n        if (err.name === \"AbortError\" && ontimeout) {\n          ontimeout();\n        } else {\n          callback && callback(null);\n        }\n      });\n    return controller;\n  }\n\n  static xdomainRequest(\n    req: XDomainRequest,\n    method: HttpMethod,\n    endPoint: string,\n    body: RequestBody,\n    timeout: number,\n    ontimeout: TimeoutCallback | null,\n    callback: AjaxCallback | null,\n  ): XDomainRequest {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n    req.onload = () => {\n      const response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => {};\n\n    req.send(body);\n    return req;\n  }\n\n  static xhrRequest(\n    req: XMLHttpRequestLike,\n    method: HttpMethod,\n    endPoint: string,\n    headers: Headers,\n    body: RequestBody,\n    timeout: number,\n    ontimeout: TimeoutCallback | null,\n    callback: AjaxCallback | null,\n  ): XMLHttpRequestLike {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    for (const [key, value] of Object.entries(headers)) {\n      req.setRequestHeader(key, value);\n    }\n    req.onerror = () => callback && callback(null);\n    req.onreadystatechange = () => {\n      if (req.readyState === XHR_STATES.complete && callback) {\n        const response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n\n    req.send(body);\n    return req;\n  }\n\n  static parseJSON(resp: string | null | undefined): any {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n\n    try {\n      return JSON.parse(resp);\n    } catch {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n\n  static serialize(obj: Record<string, any>, parentKey?: string): string {\n    const queryStr: string[] = [];\n    for (const key in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        continue;\n      }\n      const paramKey = parentKey ? `${parentKey}[${key}]` : key;\n      const paramVal = obj[key];\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(\n          encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal),\n        );\n      }\n    }\n    return queryStr.join(\"&\");\n  }\n\n  static appendParams(url: string, params: Record<string, any>): string {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return `${url}${prefix}${this.serialize(params)}`;\n  }\n}\n", "import {\n  SOCKET_STATES,\n  TRANSPORTS,\n  AUTH_TOKEN_PREFIX,\n  type SocketState,\n} from \"./constants\";\n\nimport Ajax from \"./ajax\";\n\nfunction arrayBufferToBase64(buffer: ArrayBuffer): string {\n  let binary = \"\";\n  const bytes = new Uint8Array(buffer);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]!);\n  }\n  return btoa(binary);\n}\n\ninterface LongPollResponse {\n  status: number;\n  token?: string;\n  messages?: string[];\n}\n\ninterface MessageEvent {\n  data: string;\n}\n\ninterface CloseEventInit {\n  code?: number;\n  reason?: string;\n  wasClean?: boolean;\n}\n\nexport default class LongPoll {\n  public endPoint: string | null;\n  public token: string | null;\n  public skipHeartbeat: boolean;\n  public reqs: Set<any>;\n  public awaitingBatchAck: boolean;\n  public currentBatch: string[] | null;\n  public currentBatchTimer: number | null;\n  public batchBuffer: string[];\n  public onopen: (event: any) => void;\n  public onerror: (error: any) => void;\n  public onmessage: (event: MessageEvent) => void;\n  public onclose: (event: CloseEvent | CloseEventInit) => void;\n  public pollEndpoint: string;\n  public readyState: SocketState;\n  public timeout: number;\n  public authToken?: string;\n\n  constructor(endPoint: string, protocols?: string[]) {\n    // we only support subprotocols for authToken\n    // [\"phoenix\", \"base64url.bearer.phx.BASE64_ENCODED_TOKEN\"]\n    if (\n      protocols &&\n      protocols.length === 2 &&\n      protocols[1]!.startsWith(AUTH_TOKEN_PREFIX)\n    ) {\n      this.authToken = atob(protocols[1]!.slice(AUTH_TOKEN_PREFIX.length));\n    }\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.reqs = new Set();\n    this.awaitingBatchAck = false;\n    this.currentBatch = null;\n    this.currentBatchTimer = null;\n    this.batchBuffer = [];\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.timeout = 20000; // will be set by Socket\n    // we must wait for the caller to finish setting up our callbacks and timeout properties\n    setTimeout(() => this.poll(), 0);\n  }\n\n  normalizeEndpoint(endPoint: string): string {\n    return endPoint\n      .replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")\n      .replace(\n        new RegExp(\"(.*)/\" + TRANSPORTS.websocket),\n        \"$1/\" + TRANSPORTS.longpoll,\n      );\n  }\n\n  endpointURL(): string {\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n  }\n\n  closeAndRetry(code: number, reason: string, wasClean: boolean): void {\n    this.close(code, reason, wasClean);\n    this.readyState = SOCKET_STATES.connecting;\n  }\n\n  ontimeout(): void {\n    this.onerror(\"timeout\");\n    this.closeAndRetry(1005, \"timeout\", false);\n  }\n\n  isActive(): boolean {\n    return (\n      this.readyState === SOCKET_STATES.open ||\n      this.readyState === SOCKET_STATES.connecting\n    );\n  }\n\n  poll(): void {\n    const headers: Record<string, string> = { Accept: \"application/json\" };\n    if (this.authToken) {\n      headers[\"X-Phoenix-AuthToken\"] = this.authToken;\n    }\n    this.ajax(\n      \"GET\",\n      headers,\n      null,\n      () => this.ontimeout(),\n      (resp: LongPollResponse | null) => {\n        let status: number;\n        if (resp) {\n          const { status: respStatus, token } = resp;\n          status = respStatus;\n          this.token = token || null;\n        } else {\n          status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            resp!.messages!.forEach((msg) => {\n              // Tasks are what things like event handlers, setTimeout callbacks,\n              // promise resolves and more are run within.\n              // In modern browsers, there are two different kinds of tasks,\n              // microtasks and macrotasks.\n              // Microtasks are mainly used for Promises, while macrotasks are\n              // used for everything else.\n              // Microtasks always have priority over macrotasks. If the JS engine\n              // is looking for a task to run, it will always try to empty the\n              // microtask queue before attempting to run anything from the\n              // macrotask queue.\n              //\n              // For the WebSocket transport, messages always arrive in their own\n              // event. This means that if any promises are resolved from within,\n              // their callbacks will always finish execution by the time the\n              // next message event handler is run.\n              //\n              // In order to emulate this behaviour, we need to make sure each\n              // onmessage handler is run within its own macrotask.\n              setTimeout(() => this.onmessage({ data: msg }), 0);\n            });\n            this.poll();\n            break;\n          case 204:\n            this.poll();\n            break;\n          case 410:\n            this.readyState = SOCKET_STATES.open;\n            this.onopen({});\n            this.poll();\n            break;\n          case 403:\n            this.onerror(403);\n            this.close(1008, \"forbidden\", false);\n            break;\n          case 0:\n          case 500:\n            this.onerror(500);\n            this.closeAndRetry(1011, \"internal server error\", false);\n            break;\n          default:\n            throw new Error(`unhandled poll status ${status}`);\n        }\n      },\n    );\n  }\n\n  // we collect all pushes within the current event loop by\n  // setTimeout 0, which optimizes back-to-back procedural\n  // pushes against an empty buffer\n\n  send(body: string | ArrayBuffer): void {\n    let bodyStr: string;\n    if (typeof body !== \"string\") {\n      bodyStr = arrayBufferToBase64(body);\n    } else {\n      bodyStr = body;\n    }\n    if (this.currentBatch) {\n      this.currentBatch.push(bodyStr);\n    } else if (this.awaitingBatchAck) {\n      this.batchBuffer.push(bodyStr);\n    } else {\n      this.currentBatch = [bodyStr];\n      this.currentBatchTimer = setTimeout(() => {\n        this.batchSend(this.currentBatch!);\n        this.currentBatch = null;\n      }, 0) as any;\n    }\n  }\n\n  batchSend(messages: string[]): void {\n    this.awaitingBatchAck = true;\n    this.ajax(\n      \"POST\",\n      { \"Content-Type\": \"application/x-ndjson\" },\n      messages.join(\"\\n\"),\n      () => this.onerror(\"timeout\"),\n      (resp: any) => {\n        this.awaitingBatchAck = false;\n        if (!resp || resp.status !== 200) {\n          this.onerror(resp && resp.status);\n          this.closeAndRetry(1011, \"internal server error\", false);\n        } else if (this.batchBuffer.length > 0) {\n          this.batchSend(this.batchBuffer);\n          this.batchBuffer = [];\n        }\n      },\n    );\n  }\n\n  close(code?: number, reason?: string, wasClean?: boolean): void {\n    for (const req of this.reqs) {\n      req.abort();\n    }\n    this.readyState = SOCKET_STATES.closed;\n    const opts = Object.assign(\n      { code: 1000, reason: undefined, wasClean: true },\n      { code, reason, wasClean },\n    );\n    this.batchBuffer = [];\n    if (this.currentBatchTimer !== null) {\n      clearTimeout(this.currentBatchTimer);\n      this.currentBatchTimer = null;\n    }\n    if (typeof CloseEvent !== \"undefined\") {\n      this.onclose(new CloseEvent(\"close\", opts));\n    } else {\n      this.onclose(opts);\n    }\n  }\n\n  ajax(\n    method: \"GET\" | \"POST\",\n    headers: Record<string, string>,\n    body: string | null,\n    onCallerTimeout: () => void,\n    callback: (resp: any) => void,\n  ): void {\n    const ontimeout = () => {\n      this.reqs.delete(req);\n      onCallerTimeout();\n    };\n    const req = Ajax.request(\n      method,\n      this.endpointURL(),\n      headers,\n      body,\n      this.timeout,\n      ontimeout,\n      (resp: any) => {\n        this.reqs.delete(req);\n        if (this.isActive()) {\n          callback(resp);\n        }\n      },\n    );\n    this.reqs.add(req);\n  }\n}\n", "import type Channel from \"./channel\";\n\nexport interface PresenceMeta {\n  phx_ref: string;\n  [key: string]: any;\n}\n\nexport interface PresenceState {\n  metas: PresenceMeta[];\n  [key: string]: any;\n}\n\nexport interface PresenceMap {\n  [key: string]: PresenceState;\n}\n\nexport interface PresenceDiff {\n  joins: PresenceMap;\n  leaves: PresenceMap;\n}\n\nexport interface PresenceOptions {\n  events?: {\n    state: string;\n    diff: string;\n  };\n}\n\nexport type PresenceCallback = (\n  key: string,\n  current: PresenceState | undefined,\n  newPres: PresenceState,\n) => void;\nexport type PresenceSyncCallback = () => void;\nexport type PresenceChooser<T = PresenceState> = (\n  key: string,\n  presence: PresenceState,\n) => T;\n\n/**\n * Initializes the Presence\n * @param channel - The Channel\n * @param opts - The options, for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\nexport default class Presence {\n  public state: PresenceMap;\n  public pendingDiffs: PresenceDiff[];\n  public channel: Channel;\n  public joinRef: string | null;\n  public caller: {\n    onJoin: PresenceCallback;\n    onLeave: PresenceCallback;\n    onSync: PresenceSyncCallback;\n  };\n\n  constructor(channel: Channel, opts: PresenceOptions = {}) {\n    const events = opts.events || {\n      state: \"presence_state\",\n      diff: \"presence_diff\",\n    };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function () {},\n      onLeave: function () {},\n      onSync: function () {},\n    };\n\n    this.channel.on(events.state, (newState: PresenceMap) => {\n      const { onJoin, onLeave, onSync } = this.caller;\n\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n\n      this.pendingDiffs.forEach((diff) => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n\n    this.channel.on(events.diff, (diff: PresenceDiff) => {\n      const { onJoin, onLeave, onSync } = this.caller;\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onJoin(callback: PresenceCallback): void {\n    this.caller.onJoin = callback;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onLeave(callback: PresenceCallback): void {\n    this.caller.onLeave = callback;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onSync(callback: PresenceSyncCallback): void {\n    this.caller.onSync = callback;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  list<T = PresenceState>(by?: PresenceChooser<T>): T[] {\n    return Presence.list(this.state, by);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  inPendingSyncState(): boolean {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  }\n\n  // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   */\n  static syncState(\n    currentState: PresenceMap,\n    newState: PresenceMap,\n    onJoin?: PresenceCallback,\n    onLeave?: PresenceCallback,\n  ): PresenceMap {\n    const state = this.clone(currentState);\n    const joins: PresenceMap = {};\n    const leaves: PresenceMap = {};\n\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      const currentPresence = state[key];\n      if (currentPresence) {\n        const newRefs = newPresence.metas.map((m) => m.phx_ref);\n        const curRefs = currentPresence.metas.map((m) => m.phx_ref);\n        const joinedMetas = newPresence.metas.filter(\n          (m) => curRefs.indexOf(m.phx_ref) < 0,\n        );\n        const leftMetas = currentPresence.metas.filter(\n          (m) => newRefs.indexOf(m.phx_ref) < 0,\n        );\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key]!.metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key]!.metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(\n      state,\n      { joins: joins, leaves: leaves },\n      onJoin,\n      onLeave,\n    );\n  }\n\n  /**\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   */\n  static syncDiff(\n    state: PresenceMap,\n    diff: PresenceDiff,\n    onJoin?: PresenceCallback,\n    onLeave?: PresenceCallback,\n  ): PresenceMap {\n    const { joins, leaves } = this.clone(diff);\n    if (!onJoin) {\n      onJoin = function () {};\n    }\n    if (!onLeave) {\n      onLeave = function () {};\n    }\n\n    this.map(joins, (key, newPresence) => {\n      const currentPresence = state[key];\n      state[key] = this.clone(newPresence);\n      if (currentPresence) {\n        const joinedRefs = state[key]!.metas.map((m) => m.phx_ref);\n        const curMetas = currentPresence.metas.filter(\n          (m) => joinedRefs.indexOf(m.phx_ref) < 0,\n        );\n        state[key]!.metas.unshift(...curMetas);\n      }\n      onJoin!(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      const currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      const refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter((p) => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave!(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n\n  /**\n   * Returns the array of presences, with selected metadata.\n   */\n  static list<T = PresenceState>(\n    presences: PresenceMap,\n    chooser?: PresenceChooser<T>,\n  ): T[] {\n    if (!chooser) {\n      chooser = function (key, pres) {\n        return pres as any;\n      };\n    }\n\n    return this.map(presences, (key, presence) => {\n      return chooser!(key, presence);\n    });\n  }\n\n  // private\n\n  private static map<T>(\n    obj: PresenceMap,\n    func: (key: string, presence: PresenceState) => T,\n  ): T[] {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]!));\n  }\n\n  private static clone<T>(obj: T): T {\n    return JSON.parse(JSON.stringify(obj));\n  }\n}\n", "/* The default serializer for encoding and decoding messages */\nimport { CHANNEL_EVENTS } from \"./constants\";\n\nexport interface Message {\n  join_ref: string | null;\n  ref: string | null;\n  topic: string;\n  event: string;\n  payload: any;\n}\n\nexport interface BinaryMessage {\n  join_ref: string;\n  ref: string;\n  event: string;\n  topic: string;\n  payload: ArrayBuffer;\n}\n\nexport interface ReplyPayload {\n  status: string;\n  response: ArrayBuffer;\n}\n\nconst Serializer = {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: { push: 0, reply: 1, broadcast: 2 } as const,\n\n  encode(\n    msg: Message | BinaryMessage,\n    callback: (encoded: string | ArrayBuffer) => void,\n  ): void {\n    if (msg.payload.constructor === ArrayBuffer) {\n      return callback(this.binaryEncode(msg as BinaryMessage));\n    } else {\n      const payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n      return callback(JSON.stringify(payload));\n    }\n  },\n\n  decode(\n    rawPayload: string | ArrayBuffer,\n    callback: (decoded: Message) => void,\n  ): void {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this.binaryDecode(rawPayload as ArrayBuffer));\n    } else {\n      const [join_ref, ref, topic, event, payload] = JSON.parse(\n        rawPayload as string,\n      );\n      return callback({ join_ref, ref, topic, event, payload });\n    }\n  },\n\n  // private\n\n  binaryEncode(message: BinaryMessage): ArrayBuffer {\n    const { join_ref, ref, event, topic, payload } = message;\n    const metaLength =\n      this.META_LENGTH +\n      join_ref.length +\n      ref.length +\n      topic.length +\n      event.length;\n    const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n    const view = new DataView(header);\n    let offset = 0;\n\n    view.setUint8(offset++, this.KINDS.push); // kind\n    view.setUint8(offset++, join_ref.length);\n    view.setUint8(offset++, ref.length);\n    view.setUint8(offset++, topic.length);\n    view.setUint8(offset++, event.length);\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\n\n    const combined = new Uint8Array(header.byteLength + payload.byteLength);\n    combined.set(new Uint8Array(header), 0);\n    combined.set(new Uint8Array(payload), header.byteLength);\n\n    return combined.buffer;\n  },\n\n  binaryDecode(buffer: ArrayBuffer): Message {\n    const view = new DataView(buffer);\n    const kind = view.getUint8(0);\n    const decoder = new TextDecoder();\n    switch (kind) {\n      case this.KINDS.push:\n        return this.decodePush(buffer, view, decoder);\n      case this.KINDS.reply:\n        return this.decodeReply(buffer, view, decoder);\n      case this.KINDS.broadcast:\n        return this.decodeBroadcast(buffer, view, decoder);\n      default:\n        throw new Error(`Unknown message kind: ${kind}`);\n    }\n  },\n\n  decodePush(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder,\n  ): Message {\n    const joinRefSize = view.getUint8(1);\n    const topicSize = view.getUint8(2);\n    const eventSize = view.getUint8(3);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1; // pushes have no ref\n    const joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    const data = buffer.slice(offset, buffer.byteLength);\n    return {\n      join_ref: joinRef,\n      ref: null,\n      topic: topic,\n      event: event,\n      payload: data,\n    };\n  },\n\n  decodeReply(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder,\n  ): Message {\n    const joinRefSize = view.getUint8(1);\n    const refSize = view.getUint8(2);\n    const topicSize = view.getUint8(3);\n    const eventSize = view.getUint8(4);\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\n    const joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n    offset = offset + joinRefSize;\n    const ref = decoder.decode(buffer.slice(offset, offset + refSize));\n    offset = offset + refSize;\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    const data = buffer.slice(offset, buffer.byteLength);\n    const payload: ReplyPayload = { status: event, response: data };\n    return {\n      join_ref: joinRef,\n      ref: ref,\n      topic: topic,\n      event: CHANNEL_EVENTS.reply,\n      payload: payload,\n    };\n  },\n\n  decodeBroadcast(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder,\n  ): Message {\n    const topicSize = view.getUint8(1);\n    const eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    const data = buffer.slice(offset, buffer.byteLength);\n\n    return {\n      join_ref: null,\n      ref: null,\n      topic: topic,\n      event: event,\n      payload: data,\n    };\n  },\n};\n\nexport default Serializer;\n", "import {\n  global,\n  phxWindow,\n  CHANNEL_EVENTS,\n  DEFAULT_TIMEOUT,\n  DEFAULT_VSN,\n  SOCKET_STATES,\n  TRANSPORTS,\n  WS_CLOSE_NORMAL,\n  AUTH_TOKEN_PREFIX,\n} from \"./constants\";\n\nimport { closure } from \"./utils\";\n\nimport Ajax from \"./ajax\";\nimport Channel from \"./channel\";\nimport LongPoll from \"./longpoll\";\nimport Serializer from \"./serializer\";\nimport Timer from \"./timer\";\n\n// Type definitions for WebSocket-like transport\ninterface Transport {\n  new (url: string, protocols?: string | string[]): TransportInstance;\n  name?: string;\n}\n\ntype TransportClass = Transport | typeof LongPoll;\n\n// Generic timer type that works in both Node.js and browser environments\ntype TimerHandle = ReturnType<typeof setTimeout>;\n\ninterface TransportInstance {\n  binaryType?: string;\n  timeout?: number;\n  readyState: number;\n  bufferedAmount?: number;\n  skipHeartbeat?: boolean;\n  onopen: ((event: Event) => void) | null;\n  onerror: ((event: Event) => void) | null;\n  onmessage: ((event: MessageEvent) => void) | null;\n  onclose: ((event: CloseEvent) => void) | null;\n  send(data: string | ArrayBuffer): void;\n  close(code?: number, reason?: string): void;\n}\n\n// Message structure interfaces\ninterface Message {\n  topic: string;\n  event: string;\n  payload: any;\n  ref: string | null;\n  join_ref?: string | null;\n}\n\ninterface PushData {\n  topic: string;\n  event: string;\n  payload: any;\n  ref: string;\n  join_ref?: string;\n}\n\n// Callback types\ntype StateChangeCallback = () => void;\ntype ErrorCallback = (\n  error: any,\n  transport?: Transport,\n  establishedConnections?: number,\n) => void;\ntype MessageCallback = (message: Message) => void;\ntype CloseCallback = (event: CloseEvent) => void;\ntype LoggerFunction = (kind: string, msg: string, data?: any) => void;\ntype ReconnectFunction = (tries: number) => number;\ntype EncodeFunction = (\n  payload: any,\n  callback: (encoded: string | ArrayBuffer) => void,\n) => void;\ntype DecodeFunction = (\n  payload: string | ArrayBuffer,\n  callback: (decoded: Message) => void,\n) => void;\ntype ParamsFunction = () => Record<string, any>;\ntype PingCallback = (rtt: number) => void;\n\n// Storage interface\ninterface Storage {\n  getItem(key: string): string | null;\n  setItem(key: string, value: string): void;\n  removeItem(key: string): void;\n}\n\n// Socket options interface\ninterface SocketOptions {\n  transport?: Transport;\n  longPollFallbackMs?: number;\n  debug?: boolean;\n  encode?: EncodeFunction;\n  decode?: DecodeFunction;\n  timeout?: number;\n  heartbeatIntervalMs?: number;\n  reconnectAfterMs?: ReconnectFunction;\n  rejoinAfterMs?: ReconnectFunction;\n  logger?: LoggerFunction;\n  longpollerTimeout?: number;\n  params?: Record<string, any> | ParamsFunction;\n  authToken?: string;\n  binaryType?: string;\n  vsn?: string;\n  sessionStorage?: Storage;\n}\n\n// State change callbacks structure\ninterface StateChangeCallbacks {\n  open: Array<[string, StateChangeCallback]>;\n  close: Array<[string, CloseCallback]>;\n  error: Array<[string, ErrorCallback]>;\n  message: Array<[string, MessageCallback]>;\n}\n\n/** Initializes the Socket *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {Function} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback if WebSocket is not defined.\n * To fallback to LongPoll when WebSocket attempts fail, use `longPollFallbackMs: 2500`.\n *\n * @param {number} [opts.longPollFallbackMs] - The millisecond time to attempt the primary transport\n * before falling back to the LongPoll transport. Disabled by default.\n *\n * @param {boolean} [opts.debug] - When true, enables debug logging. Default false.\n *\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON encoder.\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {Function} [opts.reconnectAfterMs] - The optional function that returns the\n * socket reconnect interval, in milliseconds.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {Function} [opts.rejoinAfterMs] - The optional function that returns the millisec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {(Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.authToken] - the optional authentication token to be exposed on the server\n * under the `:auth_token` connect_info key.\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n * @param {vsn} [opts.vsn] - The serializer's protocol version to send on connect.\n *\n * Defaults to DEFAULT_VSN.\n *\n * @param {Object} [opts.sessionStorage] - An optional Storage compatible object\n * Phoenix uses sessionStorage for longpoll fallback history. Overriding the store is\n * useful when Phoenix won't have access to `sessionStorage`. For example, This could\n * happen if a site loads a cross-domain channel in an iframe. Example usage:\n *\n *     class InMemoryStorage {\n *       constructor() { this.storage = {} }\n *       getItem(keyName) { return this.storage[keyName] || null }\n *       removeItem(keyName) { delete this.storage[keyName] }\n *       setItem(keyName, keyValue) { this.storage[keyName] = keyValue }\n *     }\n *\n */\nexport default class Socket {\n  private stateChangeCallbacks: StateChangeCallbacks;\n  private channels: Channel[];\n  private sendBuffer: Array<() => void>;\n  private ref: number;\n  private transport: TransportClass;\n  private primaryPassedHealthCheck: boolean;\n  private longPollFallbackMs: number | null;\n  private fallbackTimer: TimerHandle | null;\n  private sessionStore: Storage | null;\n  private establishedConnections: number;\n  private defaultEncoder: EncodeFunction;\n  private defaultDecoder: DecodeFunction;\n  private closeWasClean: boolean;\n  private disconnecting: boolean;\n  private binaryType: string;\n  private connectClock: number;\n  private encode: EncodeFunction;\n  private decode: DecodeFunction;\n  private heartbeatIntervalMs: number;\n  private reconnectAfterMs: ReconnectFunction;\n  private logger: LoggerFunction | null;\n  private longpollerTimeout: number;\n  private params: ParamsFunction;\n  private endPoint: string;\n  private vsn: string;\n  private heartbeatTimeoutTimer: TimerHandle | null;\n  private heartbeatTimer: TimerHandle | null;\n  private pendingHeartbeatRef: string | null;\n  private reconnectTimer: Timer;\n  private authToken?: string;\n  private conn: TransportInstance | null;\n\n  /**\n   * @internal\n   * @private\n   */\n  timeout: number;\n\n  /**\n   * @internal\n   * @private\n   */\n  rejoinAfterMs: ReconnectFunction;\n\n  constructor(endPoint: string, opts: SocketOptions = {}) {\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.primaryPassedHealthCheck = false;\n    this.longPollFallbackMs = opts.longPollFallbackMs ?? null;\n    this.fallbackTimer = null;\n    this.sessionStore =\n      opts.sessionStorage || (global && global.sessionStorage);\n    this.establishedConnections = 0;\n    this.defaultEncoder = Serializer.encode.bind(Serializer);\n    this.defaultDecoder = Serializer.decode.bind(Serializer);\n    this.closeWasClean = false;\n    this.disconnecting = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n    this.connectClock = 1;\n    this.conn = null;\n\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n\n    let awaitingConnectionOnPageShow: number | null = null;\n    if (phxWindow && phxWindow.addEventListener) {\n      phxWindow.addEventListener(\"pagehide\", (_e: Event) => {\n        if (this.conn) {\n          this.disconnect();\n          awaitingConnectionOnPageShow = this.connectClock;\n        }\n      });\n      phxWindow.addEventListener(\"pageshow\", (_e: Event) => {\n        if (awaitingConnectionOnPageShow === this.connectClock) {\n          awaitingConnectionOnPageShow = null;\n          this.connect();\n        }\n      });\n    }\n\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.rejoinAfterMs = (tries: number) => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000;\n      }\n    };\n    this.reconnectAfterMs = (tries: number) => {\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000;\n      }\n    };\n    this.logger = opts.logger || null;\n    if (!this.logger && opts.debug) {\n      this.logger = (kind: string, msg: string, data?: any) => {\n        console.log(`${kind}: ${msg}`, data);\n      };\n    }\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = closure(opts.params || {}) as ParamsFunction;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.vsn = opts.vsn || DEFAULT_VSN;\n    this.heartbeatTimeoutTimer = null;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n    this.authToken = opts.authToken;\n  }\n\n  /**\n   * Returns the LongPoll transport reference\n   */\n  getLongPollTransport(): typeof LongPoll {\n    return LongPoll;\n  }\n\n  /**\n   * Disconnects and replaces the active transport\n   *\n   * @param {Function} newTransport - The new transport class to instantiate\n   *\n   */\n  replaceTransport(newTransport: Transport): void {\n    this.connectClock++;\n    this.closeWasClean = true;\n    clearTimeout(this.fallbackTimer!);\n    this.reconnectTimer.reset();\n    if (this.conn) {\n      this.conn.close();\n      this.conn = null;\n    }\n    this.transport = newTransport;\n  }\n\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n  protocol(): string {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n\n  /**\n   * The fully qualified socket url\n   *\n   * @returns {string}\n   */\n  endPointURL(): string {\n    const uri = Ajax.appendParams(\n      Ajax.appendParams(this.endPoint, this.params()),\n      { vsn: this.vsn },\n    );\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n    if (uri.charAt(1) === \"/\") {\n      return `${this.protocol()}:${uri}`;\n    }\n\n    return `${this.protocol()}://${location.host}${uri}`;\n  }\n\n  /**\n   * Disconnects the socket\n   *\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.\n   *\n   * @param {Function} callback - Optional callback which is called after socket is disconnected.\n   * @param {integer} code - A status code for disconnection (Optional).\n   * @param {string} reason - A textual description of the reason to disconnect. (Optional)\n   */\n  disconnect(callback?: () => void, code?: number, reason?: string): void {\n    this.connectClock++;\n    this.disconnecting = true;\n    this.closeWasClean = true;\n    clearTimeout(this.fallbackTimer!);\n    this.reconnectTimer.reset();\n    this.teardown(\n      () => {\n        this.disconnecting = false;\n        callback && callback();\n      },\n      code,\n      reason,\n    );\n  }\n\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n  connect(params?: Record<string, any>): void {\n    if (params) {\n      console &&\n        console.log(\n          \"passing params to connect is deprecated. Instead pass :params to the Socket constructor\",\n        );\n      this.params = closure(params) as ParamsFunction;\n    }\n    if (this.conn && !this.disconnecting) {\n      return;\n    }\n    if (this.longPollFallbackMs && this.transport !== LongPoll) {\n      this.connectWithFallback(LongPoll, this.longPollFallbackMs);\n    } else {\n      this.transportConnect();\n    }\n  }\n\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n  log(kind: string, msg: string, data?: any): void {\n    this.logger && this.logger(kind, msg, data);\n  }\n\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n  hasLogger(): boolean {\n    return this.logger !== null;\n  }\n\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n  onOpen(callback: StateChangeCallback): string {\n    const ref = this.makeRef();\n    this.stateChangeCallbacks.open.push([ref, callback]);\n    return ref;\n  }\n\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n  onClose(callback: CloseCallback): string {\n    const ref = this.makeRef();\n    this.stateChangeCallbacks.close.push([ref, callback]);\n    return ref;\n  }\n\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n  onError(callback: ErrorCallback): string {\n    const ref = this.makeRef();\n    this.stateChangeCallbacks.error.push([ref, callback]);\n    return ref;\n  }\n\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n  onMessage(callback: MessageCallback): string {\n    const ref = this.makeRef();\n    this.stateChangeCallbacks.message.push([ref, callback]);\n    return ref;\n  }\n\n  /**\n   * Pings the server and invokes the callback with the RTT in milliseconds\n   * @param {Function} callback\n   *\n   * Returns true if the ping was pushed or false if unable to be pushed.\n   */\n  ping(callback: PingCallback): boolean {\n    if (!this.isConnected()) {\n      return false;\n    }\n    const ref = this.makeRef();\n    const startTime = Date.now();\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: ref });\n    const onMsgRef = this.onMessage((msg) => {\n      if (msg.ref === ref) {\n        this.off([onMsgRef]);\n        callback(Date.now() - startTime);\n      }\n    });\n    return true;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  transportConnect(): void {\n    this.connectClock++;\n    this.closeWasClean = false;\n    let protocols: string[] | undefined = undefined;\n    // Sec-WebSocket-Protocol based token\n    // (longpoll uses Authorization header instead)\n    if (this.authToken) {\n      protocols = [\n        \"phoenix\",\n        `${AUTH_TOKEN_PREFIX}${btoa(this.authToken).replace(/=/g, \"\")}`,\n      ];\n    }\n    this.conn = new this.transport(this.endPointURL(), protocols);\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n    this.conn.onopen = () => this.onConnOpen();\n    this.conn.onerror = (error) => this.onConnError(error);\n    this.conn.onmessage = (event) => this.onConnMessage(event);\n    this.conn.onclose = (event) => this.onConnClose(event);\n  }\n\n  private getSession(key: string): string | null {\n    return this.sessionStore && this.sessionStore.getItem(key);\n  }\n\n  private storeSession(key: string, val: string): void {\n    this.sessionStore && this.sessionStore.setItem(key, val);\n  }\n\n  private connectWithFallback(\n    fallbackTransport: Transport,\n    fallbackThreshold: number = 2500,\n  ): void {\n    clearTimeout(this.fallbackTimer!);\n    let established = false;\n    let primaryTransport = true;\n    let openRef: string;\n    const fallback = (reason: any) => {\n      this.log(\n        \"transport\",\n        `falling back to ${fallbackTransport.name}...`,\n        reason,\n      );\n      this.off([openRef, errorRef]);\n      primaryTransport = false;\n      this.replaceTransport(fallbackTransport);\n      this.transportConnect();\n    };\n    if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {\n      return fallback(\"memorized\");\n    }\n\n    this.fallbackTimer = setTimeout(fallback, fallbackThreshold);\n\n    const errorRef = this.onError((reason) => {\n      this.log(\"transport\", \"error\", reason);\n      if (primaryTransport && !established) {\n        clearTimeout(this.fallbackTimer!);\n        fallback(reason);\n      }\n    });\n    this.onOpen(() => {\n      established = true;\n      if (!primaryTransport) {\n        // only memorize LP if we never connected to primary\n        if (!this.primaryPassedHealthCheck) {\n          this.storeSession(`phx:fallback:${fallbackTransport.name}`, \"true\");\n        }\n        return this.log(\n          \"transport\",\n          `established ${fallbackTransport.name} fallback`,\n        );\n      }\n      // if we've established primary, give the fallback a new period to attempt ping\n      clearTimeout(this.fallbackTimer!);\n      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);\n      this.ping((rtt) => {\n        this.log(\"transport\", \"connected to primary after\", rtt);\n        this.primaryPassedHealthCheck = true;\n        clearTimeout(this.fallbackTimer!);\n      });\n    });\n    this.transportConnect();\n  }\n\n  private clearHeartbeats(): void {\n    clearTimeout(this.heartbeatTimer!);\n    clearTimeout(this.heartbeatTimeoutTimer!);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onConnOpen(): void {\n    if (this.hasLogger())\n      this.log(\n        \"transport\",\n        `${this.transport.name} connected to ${this.endPointURL()}`,\n      );\n    this.closeWasClean = false;\n    this.disconnecting = false;\n    this.establishedConnections++;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n  }\n\n  private heartbeatTimeout(): void {\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) {\n        this.log(\n          \"transport\",\n          \"heartbeat timeout. Attempting to re-establish connection\",\n        );\n      }\n      this.triggerChanError();\n      this.closeWasClean = false;\n      this.teardown(\n        () => this.reconnectTimer.scheduleTimeout(),\n        WS_CLOSE_NORMAL,\n        \"heartbeat timeout\",\n      );\n    }\n  }\n\n  private resetHeartbeat(): void {\n    if (this.conn && this.conn.skipHeartbeat) {\n      return;\n    }\n    this.pendingHeartbeatRef = null;\n    this.clearHeartbeats();\n    this.heartbeatTimer = setTimeout(\n      () => this.sendHeartbeat(),\n      this.heartbeatIntervalMs,\n    );\n  }\n\n  private teardown(\n    callback?: () => void,\n    code?: number,\n    reason?: string,\n  ): void {\n    if (!this.conn) {\n      return callback && callback();\n    }\n    const connectClock = this.connectClock;\n\n    this.waitForBufferDone(() => {\n      if (connectClock !== this.connectClock) {\n        return;\n      }\n      if (this.conn) {\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n      }\n\n      this.waitForSocketClosed(() => {\n        if (connectClock !== this.connectClock) {\n          return;\n        }\n        if (this.conn) {\n          this.conn.onopen = function () {}; // noop\n          this.conn.onerror = function () {}; // noop\n          this.conn.onmessage = function () {}; // noop\n          this.conn.onclose = function () {}; // noop\n          this.conn = null;\n        }\n\n        callback && callback();\n      });\n    });\n  }\n\n  private waitForBufferDone(callback: () => void, tries: number = 1): void {\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n      callback();\n      return;\n    }\n\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1);\n    }, 150 * tries);\n  }\n\n  private waitForSocketClosed(callback: () => void, tries: number = 1): void {\n    if (\n      tries === 5 ||\n      !this.conn ||\n      this.conn.readyState === SOCKET_STATES.closed\n    ) {\n      callback();\n      return;\n    }\n\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1);\n    }, 150 * tries);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onConnClose(event: CloseEvent): void {\n    const closeCode = event && event.code;\n    if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    this.clearHeartbeats();\n    if (!this.closeWasClean && closeCode !== 1000) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onConnError(error: Event): void {\n    if (this.hasLogger()) this.log(\"transport\", \"error\", error);\n    const transportBefore = this.transport;\n    const establishedBefore = this.establishedConnections;\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore);\n    });\n    if (transportBefore === this.transport || establishedBefore > 0) {\n      this.triggerChanError();\n    }\n  }\n\n  private triggerChanError(): void {\n    this.channels.forEach((channel) => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error, {});\n      }\n    });\n  }\n\n  /**\n   * @returns {string}\n   */\n  connectionState(): string {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n      case SOCKET_STATES.open:\n        return \"open\";\n      case SOCKET_STATES.closing:\n        return \"closing\";\n      default:\n        return \"closed\";\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isConnected(): boolean {\n    return this.connectionState() === \"open\";\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * @param {Channel}\n   */\n  remove(channel: Channel): void {\n    this.off(channel.stateChangeRefs);\n    this.channels = this.channels.filter((c) => c !== channel);\n  }\n\n  /**\n   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.\n   *\n   * @param {refs} - list of refs returned by calls to\n   *                 `onOpen`, `onClose`, `onError,` and `onMessage`\n   */\n  off(refs: string[]): void {\n    const filter = (callbacks: Array<[string, any]>) =>\n      callbacks.filter(([ref]) => refs.indexOf(ref) === -1);\n\n    this.stateChangeCallbacks = {\n      open: filter(this.stateChangeCallbacks.open),\n      close: filter(this.stateChangeCallbacks.close),\n      error: filter(this.stateChangeCallbacks.error),\n      message: filter(this.stateChangeCallbacks.message),\n    };\n  }\n\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n  channel(topic: string, chanParams: Record<string, any> = {}): Channel {\n    const chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n\n  /**\n   * @param {Object} data\n   */\n  push(data: PushData): void {\n    if (this.hasLogger()) {\n      const { topic, event, payload, ref, join_ref } = data;\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n    }\n\n    if (this.isConnected()) {\n      this.encode(data, (result) => this.conn!.send(result));\n    } else {\n      this.sendBuffer.push(() =>\n        this.encode(data, (result) => this.conn!.send(result)),\n      );\n    }\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n  makeRef(): string {\n    const newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  sendHeartbeat(): void {\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({\n      topic: \"phoenix\",\n      event: \"heartbeat\",\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    });\n    this.heartbeatTimeoutTimer = setTimeout(\n      () => this.heartbeatTimeout(),\n      this.heartbeatIntervalMs,\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  flushSendBuffer(): void {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  onConnMessage(rawMessage: MessageEvent): void {\n    this.decode(rawMessage.data, (msg) => {\n      const { topic, event, payload, ref, join_ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.clearHeartbeats();\n        this.pendingHeartbeatRef = null;\n        this.heartbeatTimer = setTimeout(\n          () => this.sendHeartbeat(),\n          this.heartbeatIntervalMs,\n        );\n      }\n\n      if (this.hasLogger())\n        this.log(\n          \"receive\",\n          `${payload.status || \"\"} ${topic} ${event} ${(ref && \"(\" + ref + \")\") || \"\"}`,\n          payload,\n        );\n\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n        channel.trigger(event, payload, ref, join_ref);\n      }\n\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        const [, callback] = this.stateChangeCallbacks.message[i];\n        callback(msg);\n      }\n    });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  leaveOpenTopic(topic: string): void {\n    const dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c.isJoined() || c.isJoining()),\n    );\n    if (dupChannel) {\n      if (this.hasLogger())\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.leave();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
